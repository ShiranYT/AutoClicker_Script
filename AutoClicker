import customtkinter as ctk
import pyautogui
import keyboard
import threading
import time
import json
import os
import random
from PIL import Image, ImageDraw
import logging

# Configure logging for debugging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

# Configure pyautogui for safe operation
pyautogui.FAILSAFE = True
pyautogui.PAUSE = 0.02  # Set for ~50 CPS max

class AutoClickerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("AutoClicker")
        self.root.geometry("600x650")
        self.root.resizable(False, False)
        self.is_running = False
        self.thread = None
        self.bg_start_color = (25, 15, 60)
        self.bg_end_color = (70, 50, 180)
        self.button_color = "#8b5cf6"
        self.title_color = "#e9d5ff"
        self.font_type = "Inter"
        self.font_size = 16
        self.click_type_value = "None"
        self.click_duration = 0
        self.random_delay = 0
        self.mouse_move_enabled = False
        self.double_click_enabled = False
        self.burst_count = 1
        self.click_limit = 0
        self.use_fixed_pos = False
        self.fixed_pos = None
        self.total_clicks = 0
        self.opacity = 0.95
        self.auto_stop_time = 0
        self.cps_limit = 50  # Safer CPS limit
        self.log_enabled = False
        self.jitter_amount = 0
        self.min_interval = 0.02  # Corresponds to 50 CPS
        self.current_key = "None"
        self.hotkey = "f6"
        self.gradient_t = 0.0
        self.gradient_direction = 1
        self.gradient_speed = 20
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("dark-blue")

        # Load saved state
        self.load_state()

        self.root.attributes('-alpha', self.opacity)

        # Create gradient background
        self.bg_image = self.create_gradient_background()
        self.bg_label = ctk.CTkLabel(self.root, text="", image=self.bg_image)
        self.bg_label.place(x=0, y=0, relwidth=1, relheight=1)
        self.update_gradient()

        # Main frame
        self.border_frame = ctk.CTkFrame(root, corner_radius=20, fg_color="#8b5cf6")
        self.border_frame.pack(pady=20, padx=20, fill="both", expand=True)
        self.main_frame = ctk.CTkFrame(self.border_frame, corner_radius=20, fg_color="#1e1e2e")
        self.main_frame.pack(pady=3, padx=3, fill="both", expand=True)

        # Title
        self.title_label = ctk.CTkLabel(
            self.main_frame,
            text="AutoClicker",
            font=(self.font_type, self.font_size + 16, "bold"),
            text_color=self.title_color,
            fg_color="transparent",
            corner_radius=10
        )
        self.title_label.pack(pady=(20, 10))

        # Input sections
        self.create_input_section()

        # Start/Stop button
        self.start_stop_btn = ctk.CTkButton(
            self.main_frame,
            text=f"Start ({self.hotkey.upper()})",
            command=self.toggle_automation,
            corner_radius=25,
            fg_color=self.button_color,
            hover_color="#a78bfa",
            font=(self.font_type, self.font_size + 4, "bold"),
            height=50,
            border_width=2,
            border_color="#d8b4fe",
            width=300
        )
        self.start_stop_btn.pack(pady=20)

        # Settings button
        self.settings_btn = ctk.CTkButton(
            self.main_frame,
            text="⚙ Settings",
            command=self.open_settings,
            corner_radius=25,
            fg_color="#3b82f6",
            hover_color="#60a5fa",
            font=(self.font_type, self.font_size),
            height=40,
            width=300
        )
        self.settings_btn.pack(pady=5)

        # Status label
        self.status_label = ctk.CTkLabel(
            self.main_frame,
            text="Status: Stopped",
            font=(self.font_type, self.font_size),
            text_color="#22c55e" if self.is_running else "#e9d5ff"
        )
        self.status_label.pack(pady=10)

        self.bind_hotkey()
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)

    def create_gradient_background(self):
        # Create a smooth gradient background
        width, height = 600, 650
        image = Image.new("RGB", (width, height))
        draw = ImageDraw.Draw(image)
        for y in range(height):
            t = y / height
            r = int(self.bg_start_color[0] + t * (self.bg_end_color[0] - self.bg_start_color[0]))
            g = int(self.bg_start_color[1] + t * (self.bg_end_color[1] - self.bg_start_color[1]))
            b = int(self.bg_start_color[2] + t * (self.bg_end_color[2] - self.bg_start_color[2]))
            draw.line((0, y, width, y), fill=(r, g, b))
        return ctk.CTkImage(dark_image=image, size=(width, height))

    def update_gradient(self):
        # Animate gradient background
        self.gradient_t += self.gradient_direction * (self.gradient_speed / 1000.0)
        if self.gradient_t >= 1.0:
            self.gradient_t = 1.0
            self.gradient_direction = -1
        elif self.gradient_t <= 0.0:
            self.gradient_t = 0.0
            self.gradient_direction = 1

        current_start = (
            int(self.bg_start_color[0] + self.gradient_t * (self.bg_end_color[0] - self.bg_start_color[0])),
            int(self.bg_start_color[1] + self.gradient_t * (self.bg_end_color[1] - self.bg_start_color[1])),
            int(self.bg_start_color[2] + self.gradient_t * (self.bg_end_color[2] - self.bg_start_color[2]))
        )
        current_end = (
            int(self.bg_end_color[0] + self.gradient_t * (self.bg_start_color[0] - self.bg_end_color[0])),
            int(self.bg_end_color[1] + self.gradient_t * (self.bg_start_color[1] - self.bg_end_color[1])),
            int(self.bg_end_color[2] + self.gradient_t * (self.bg_start_color[2] - self.bg_end_color[2]))
        )

        width, height = 600, 650
        image = Image.new("RGB", (width, height))
        draw = ImageDraw.Draw(image)
        for y in range(height):
            t_y = y / height
            r = int(current_start[0] + t_y * (current_end[0] - current_start[0]))
            g = int(current_start[1] + t_y * (current_end[1] - current_start[1]))
            b = int(current_start[2] + t_y * (current_end[2] - current_start[0]))
            draw.line((0, y, width, y), fill=(r, g, b))

        self.bg_image = ctk.CTkImage(dark_image=image, size=(width, height))
        self.bg_label.configure(image=self.bg_image)
        self.root.after(self.gradient_speed, self.update_gradient)

    def create_input_section(self):
        # Click Type
        click_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        click_frame.pack(pady=10, fill="x")
        ctk.CTkLabel(click_frame, text="Click Type", font=(self.font_type, self.font_size)).pack()
        self.click_type = ctk.CTkComboBox(
            click_frame,
            values=["None", "Left", "Right"],
            state="readonly",
            width=300,
            height=40,
            corner_radius=15,
            dropdown_fg_color="#2a2a3a",
            button_color=self.button_color,
            button_hover_color="#a78bfa",
            font=(self.font_type, self.font_size),
            border_color="#8b5cf6",
            border_width=2
        )
        self.click_type.set(self.click_type_value)
        self.click_type.pack(pady=5)

        # Key to Press
        key_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        key_frame.pack(pady=10, fill="x")
        ctk.CTkLabel(key_frame, text="Key to Press", font=(self.font_type, self.font_size)).pack()
        key_inner_frame = ctk.CTkFrame(key_frame, fg_color="transparent")
        key_inner_frame.pack(pady=5)
        self.key_entry = ctk.CTkEntry(
            key_inner_frame,
            width=200,
            height=40,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., Ctrl+A"
        )
        self.key_entry.insert(0, self.current_key)
        self.key_entry.pack(side="left", padx=5)
        self.key_entry.bind("<Return>", self.set_key)
        self.reset_button = ctk.CTkButton(
            key_inner_frame,
            text="Reset",
            command=self.reset_key,
            width=80,
            height=40,
            corner_radius=15,
            fg_color="#ef4444",
            hover_color="#f87171",
            font=(self.font_type, self.font_size)
        )
        self.reset_button.pack(side="left")

        # Hotkey
        hotkey_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        hotkey_frame.pack(pady=10, fill="x")
        ctk.CTkLabel(hotkey_frame, text="Start/Stop Hotkey", font=(self.font_type, self.font_size)).pack()
        self.hotkey_entry = ctk.CTkEntry(
            hotkey_frame,
            width=300,
            height=40,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., F6"
        )
        self.hotkey_entry.insert(0, self.hotkey)
        self.hotkey_entry.pack(pady=5)
        self.hotkey_entry.bind("<Return>", self.set_hotkey)

        # Interval
        interval_frame = ctk.CTkFrame(self.main_frame, fg_color="transparent")
        interval_frame.pack(pady=10, fill="x")
        ctk.CTkLabel(interval_frame, text="Interval", font=(self.font_type, self.font_size)).pack()
        interval_inner_frame = ctk.CTkFrame(interval_frame, fg_color="transparent")
        interval_inner_frame.pack(pady=5)
        self.min_entry = ctk.CTkEntry(interval_inner_frame, width=70, height=35, corner_radius=10, font=(self.font_type, self.font_size))
        self.min_entry.insert(0, "0")
        self.min_entry.pack(side="left", padx=5)
        ctk.CTkLabel(interval_inner_frame, text="min", font=(self.font_type, self.font_size)).pack(side="left")
        self.sec_entry = ctk.CTkEntry(interval_inner_frame, width=70, height=35, corner_radius=10, font=(self.font_type, self.font_size))
        self.sec_entry.insert(0, "0")
        self.sec_entry.pack(side="left", padx=5)
        ctk.CTkLabel(interval_inner_frame, text="sec", font=(self.font_type, self.font_size)).pack(side="left")
        self.ms_entry = ctk.CTkEntry(interval_inner_frame, width=70, height=35, corner_radius=10, font=(self.font_type, self.font_size))
        self.ms_entry.insert(0, "100")
        self.ms_entry.pack(side="left", padx=5)
        ctk.CTkLabel(interval_inner_frame, text="ms", font=(self.font_type, self.font_size)).pack(side="left")

    def get_interval(self):
        # Calculate click interval from user input
        try:
            minutes = float(self.min_entry.get()) * 60
            seconds = float(self.sec_entry.get())
            milliseconds = float(self.ms_entry.get()) / 1000
            total = minutes + seconds + milliseconds
            return max(total, self.min_interval)
        except ValueError:
            return self.min_interval

    def perform_click(self, click_type):
        # Perform a single mouse click
        if self.click_duration > 0:
            pyautogui.mouseDown(button=click_type)
            time.sleep(self.click_duration / 1000.0)
            pyautogui.mouseUp(button=click_type)
        else:
            pyautogui.click(button=click_type)

    def automation_loop(self):
        # Main automation loop for clicks or key presses
        click_type = self.click_type.get().lower()
        key = self.current_key.lower() if self.current_key != "None" else None
        interval = self.get_interval()
        start_time = time.time()
        self.total_clicks = 0

        while self.is_running:
            if self.auto_stop_time > 0 and time.time() - start_time > self.auto_stop_time:
                self.root.after(0, self.toggle_automation)
                return

            if self.use_fixed_pos and self.fixed_pos:
                pyautogui.moveTo(self.fixed_pos[0], self.fixed_pos[1], duration=0)

            if click_type != "none":
                for _ in range(self.burst_count):
                    self.perform_click(click_type)
                    if self.double_click_enabled:
                        time.sleep(0.01)
                        self.perform_click(click_type)
                    self.total_clicks += 1
                    if self.log_enabled:
                        with open("click_log.txt", "a") as f:
                            f.write(f"Click at {time.time()}\n")
                    if self.click_limit > 0 and self.total_clicks >= self.click_limit:
                        self.root.after(0, self.toggle_automation)
                        return
                    if self.mouse_move_enabled:
                        x, y = pyautogui.position()
                        offset_x = random.randint(-self.jitter_amount, self.jitter_amount)
                        offset_y = random.randint(-self.jitter_amount, self.jitter_amount)
                        pyautogui.moveTo(x + offset_x, y + offset_y, duration=0.01)
            if key:
                keys = [k.strip().lower() for k in key.split('+') if k.strip()]
                pyautogui.hotkey(*keys) if keys else pyautogui.press(key)

            delay = interval + random.uniform(0, self.random_delay / 1000.0) if self.random_delay > 0 else interval
            time.sleep(delay)

    def toggle_automation(self):
        # Toggle the automation on or off
        if not self.is_running:
            pyautogui.PAUSE = 1 / self.cps_limit if self.cps_limit > 0 else 0.02
            self.is_running = True
            self.start_stop_btn.configure(text=f"Stop ({self.hotkey.upper()})", fg_color="#ef4444", hover_color="#f87171")
            self.status_label.configure(text="Status: Running", text_color="#22c55e")
            self.thread = threading.Thread(target=self.automation_loop, daemon=True)
            self.thread.start()
            logging.info("✅ Automation started")
        else:
            self.is_running = False
            self.start_stop_btn.configure(text=f"Start ({self.hotkey.upper()})", fg_color=self.button_color, hover_color="#a78bfa")
            self.status_label.configure(text="Status: Stopped", text_color="#e9d5ff")
            self.thread = None
            logging.info("🛑 Automation stopped")

    def bind_hotkey(self):
        # Bind the hotkey for starting/stopping automation
        try:
            keyboard.unhook_all()
            keys = [k.strip().lower() for k in self.hotkey.split('+') if k.strip()]
            if keys:
                keyboard.add_hotkey('+'.join(keys), self.toggle_automation, suppress=True)
            else:
                keyboard.on_press_key(self.hotkey.lower(), lambda e: self.toggle_automation(), suppress=True)
            self.start_stop_btn.configure(text=f"Start ({self.hotkey.upper()})")
            logging.info(f"🔗 Hotkey bound to: {self.hotkey}")
        except Exception as e:
            logging.error(f"❌ Failed to bind hotkey: {e}")
            self.hotkey = "f6"
            keyboard.on_press_key(self.hotkey.lower(), lambda e: self.toggle_automation(), suppress=True)
            self.start_stop_btn.configure(text=f"Start (F6)")

    def set_key(self, event):
        # Set the key to press
        key_input = self.key_entry.get().strip()
        if key_input:
            normalized_key = key_input.lower()
            if "+" in normalized_key or normalized_key.isalnum() or normalized_key in ["space", "enter", "tab", "esc"]:
                self.current_key = normalized_key
            else:
                self.key_entry.delete(0, ctk.END)
                self.key_entry.insert(0, self.current_key)
                return
        else:
            self.current_key = "None"
        self.key_entry.delete(0, ctk.END)
        self.key_entry.insert(0, self.current_key)
        self.key_entry.focus_set()

    def set_hotkey(self, event):
        # Set the start/stop hotkey
        hotkey_input = self.hotkey_entry.get().strip()
        if hotkey_input:
            normalized_hotkey = hotkey_input.lower()
            if "+" in normalized_hotkey or normalized_hotkey.isalnum() or normalized_hotkey in ["f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "f10", "f11", "f12", "space", "enter", "tab", "esc"]:
                self.hotkey = normalized_hotkey
                self.bind_hotkey()
            else:
                self.hotkey_entry.delete(0, ctk.END)
                self.hotkey_entry.insert(0, self.hotkey)
                return
        self.hotkey_entry.delete(0, ctk.END)
        self.hotkey_entry.insert(0, self.hotkey)
        self.hotkey_entry.focus_set()

    def reset_key(self):
        # Reset the key to press
        self.current_key = "None"
        self.key_entry.delete(0, ctk.END)
        self.key_entry.insert(0, "None")
        self.key_entry.focus_set()
        logging.info("🔄 Key reset to: None")

    def fade_in_window(self, window, current=0.0, target=0.95, step=0.03, delay=10):
        # Fade in effect for settings window
        if current < target:
            window.attributes('-alpha', current)
            window.after(delay, lambda: self.fade_in_window(window, current + step, target, step, delay))
        else:
            window.attributes('-alpha', target)

    def open_settings(self):
        # Open settings window
        settings_window = ctk.CTkToplevel(self.root)
        settings_window.title("Settings")
        settings_window.geometry("450x600+610+50")
        settings_window.resizable(False, False)
        settings_window.attributes('-alpha', 0.0)
        self.fade_in_window(settings_window)

        settings_frame = ctk.CTkFrame(settings_window, corner_radius=20, fg_color="#1e1e2e", border_color="#8b5cf6", border_width=2)
        settings_frame.pack(pady=20, padx=20, fill="both", expand=True)

        tabview = ctk.CTkTabview(settings_frame, width=410, height=500, corner_radius=15, fg_color="#2a2a3a")
        tabview.pack(padx=10, pady=10, fill="both", expand=True)

        # Design Tab
        design_tab = tabview.add("Design")
        design_frame = ctk.CTkScrollableFrame(design_tab, width=390, height=450, corner_radius=15, fg_color="transparent")
        design_frame.pack(padx=5, pady=5, fill="both", expand=True)

        ctk.CTkLabel(design_frame, text="Design Settings", font=(self.font_type, self.font_size + 4, "bold")).pack(pady=10)
        ctk.CTkLabel(design_frame, text="Background Customization", font=(self.font_type, self.font_size, "bold")).pack(pady=5)
        ctk.CTkLabel(design_frame, text="Start Color", font=(self.font_type, self.font_size)).pack(pady=5)
        self.start_color_var = ctk.StringVar(value=f"#{self.bg_start_color[0]:02x}{self.bg_start_color[1]:02x}{self.bg_start_color[2]:02x}")
        ctk.CTkOptionMenu(
            design_frame,
            variable=self.start_color_var,
            values=["#19153c", "#1e2a4c", "#2e2a4c", "#4c1a2a", "#2a4c1a", "Custom"],
            command=lambda v: self.update_color("start", v),
            font=(self.font_type, self.font_size),
            corner_radius=15
        ).pack(pady=5)
        self.start_color_entry = ctk.CTkEntry(
            design_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., #FF0000"
        )
        self.start_color_entry.insert(0, self.start_color_var.get())
        self.start_color_entry.bind("<Return>", lambda e: self.update_color("start", self.start_color_entry.get()))
        self.start_color_entry.pack(pady=5)
        self.start_preview = ctk.CTkLabel(design_frame, width=60, height=25, fg_color=self.start_color_var.get(), corner_radius=10)
        self.start_preview.pack(pady=5)

        ctk.CTkLabel(design_frame, text="End Color", font=(self.font_type, self.font_size)).pack(pady=5)
        self.end_color_var = ctk.StringVar(value=f"#{self.bg_end_color[0]:02x}{self.bg_end_color[1]:02x}{self.bg_end_color[2]:02x}")
        ctk.CTkOptionMenu(
            design_frame,
            variable=self.end_color_var,
            values=["#3c32b4", "#4c66b4", "#b466b4", "#b44c66", "#66b44c", "Custom"],
            command=lambda v: self.update_color("end", v),
            font=(self.font_type, self.font_size),
            corner_radius=15
        ).pack(pady=5)
        self.end_color_entry = ctk.CTkEntry(
            design_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., #FF0000"
        )
        self.end_color_entry.insert(0, self.end_color_var.get())
        self.end_color_entry.bind("<Return>", lambda e: self.update_color("end", self.end_color_entry.get()))
        self.end_color_entry.pack(pady=5)
        self.end_preview = ctk.CTkLabel(design_frame, width=60, height=25, fg_color=self.end_color_var.get(), corner_radius=10)
        self.end_preview.pack(pady=5)

        ctk.CTkLabel(design_frame, text="Text and Button Customization", font=(self.font_type, self.font_size, "bold")).pack(pady=10)
        ctk.CTkLabel(design_frame, text="Title Color", font=(self.font_type, self.font_size)).pack(pady=5)
        self.title_color_var = ctk.StringVar(value=self.title_color)
        ctk.CTkOptionMenu(
            design_frame,
            variable=self.title_color_var,
            values=["#e9d5ff", "#ffffff", "#000000", "#ff5555", "#22c55e", "Custom"],
            command=lambda v: self.update_title_color(v),
            font=(self.font_type, self.font_size),
            corner_radius=15
        ).pack(pady=5)
        self.title_color_entry = ctk.CTkEntry(
            design_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., #FF0000"
        )
        self.title_color_entry.insert(0, self.title_color_var.get())
        self.title_color_entry.bind("<Return>", lambda e: self.update_title_color(self.title_color_entry.get()))
        self.title_color_entry.pack(pady=5)
        self.title_preview = ctk.CTkLabel(design_frame, width=60, height=25, fg_color=self.title_color_var.get(), corner_radius=10)
        self.title_preview.pack(pady=5)

        ctk.CTkLabel(design_frame, text="Button Color", font=(self.font_type, self.font_size)).pack(pady=5)
        self.button_color_var = ctk.StringVar(value=self.button_color)
        ctk.CTkOptionMenu(
            design_frame,
            variable=self.button_color_var,
            values=["#8b5cf6", "#22c55e", "#ef4444", "#eab308", "#3b82f6", "Custom"],
            command=lambda v: self.update_button_color(v),
            font=(self.font_type, self.font_size),
            corner_radius=15
        ).pack(pady=5)
        self.button_color_entry = ctk.CTkEntry(
            design_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., #FF0000"
        )
        self.button_color_entry.insert(0, self.button_color_var.get())
        self.button_color_entry.bind("<Return>", lambda e: self.update_button_color(self.button_color_entry.get()))
        self.button_color_entry.pack(pady=5)
        self.button_preview = ctk.CTkLabel(design_frame, width=60, height=25, fg_color=self.button_color_var.get(), corner_radius=10)
        self.button_preview.pack(pady=5)

        ctk.CTkLabel(design_frame, text="Font Settings", font=(self.font_type, self.font_size, "bold")).pack(pady=10)
        ctk.CTkLabel(design_frame, text="Font Size", font=(self.font_type, self.font_size)).pack(pady=5)
        self.font_slider = ctk.CTkSlider(design_frame, from_=12, to=22, command=self.update_font_size, width=300, corner_radius=10)
        self.font_slider.set(self.font_size)
        self.font_slider.pack(pady=5)
        self.font_size_label = ctk.CTkLabel(design_frame, text=f"{int(self.font_size)}", font=(self.font_type, self.font_size), text_color="#e9d5ff")
        self.font_size_label.pack(pady=2)

        ctk.CTkLabel(design_frame, text="Font Type", font=(self.font_type, self.font_size)).pack(pady=5)
        self.font_type_var = ctk.StringVar(value=self.font_type)
        ctk.CTkComboBox(
            design_frame,
            variable=self.font_type_var,
            values=["Inter", "Montserrat", "Arial", "Helvetica"],
            command=self.update_font_type,
            font=(self.font_type, self.font_size),
            corner_radius=15
        ).pack(pady=5)

        # Automation Tab
        automation_tab = tabview.add("Automation")
        automation_frame = ctk.CTkScrollableFrame(automation_tab, width=390, height=450, corner_radius=15, fg_color="transparent")
        automation_frame.pack(padx=5, pady=5, fill="both", expand=True)

        ctk.CTkLabel(automation_frame, text="Automation Settings", font=(self.font_type, self.font_size + 4, "bold")).pack(pady=10)
        ctk.CTkLabel(automation_frame, text="Click Behavior", font=(self.font_type, self.font_size, "bold")).pack(pady=5)
        ctk.CTkLabel(automation_frame, text="Click Duration (ms)", font=(self.font_type, self.font_size)).pack(pady=5)
        self.click_duration_entry = ctk.CTkEntry(
            automation_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., 0"
        )
        self.click_duration_entry.insert(0, str(self.click_duration))
        self.click_duration_entry.bind("<Return>", self.update_click_duration)
        self.click_duration_entry.pack(pady=5)

        ctk.CTkLabel(automation_frame, text="Random Delay Variation (ms)", font=(self.font_type, self.font_size)).pack(pady=5)
        self.random_delay_slider = ctk.CTkSlider(automation_frame, from_=0, to=100, command=self.update_random_delay, width=300, corner_radius=10)
        self.random_delay_slider.set(self.random_delay)
        self.random_delay_slider.pack(pady=5)
        self.random_delay_label = ctk.CTkLabel(automation_frame, text=f"{int(self.random_delay)} ms", font=(self.font_type, self.font_size), text_color="#e9d5ff")
        self.random_delay_label.pack(pady=2)

        ctk.CTkLabel(automation_frame, text="Click Options", font=(self.font_type, self.font_size, "bold")).pack(pady=10)
        mouse_move_frame = ctk.CTkFrame(automation_frame, fg_color="transparent")
        mouse_move_frame.pack(pady=5)
        ctk.CTkLabel(mouse_move_frame, text="Simulate Mouse Movement", font=(self.font_type, self.font_size)).pack(side="left", padx=5)
        self.mouse_move_var = ctk.BooleanVar(value=self.mouse_move_enabled)
        self.mouse_move_switch = ctk.CTkSwitch(
            mouse_move_frame,
            text="",
            variable=self.mouse_move_var,
            command=self.update_mouse_move,
            fg_color="#ef4444",
            progress_color=self.button_color
        )
        self.mouse_move_switch.pack(side="left", padx=2)
        self.mouse_move_label = ctk.CTkLabel(mouse_move_frame, text="On" if self.mouse_move_enabled else "Off", text_color=self.button_color if self.mouse_move_enabled else "#ef4444")
        self.mouse_move_label.pack(side="left", padx=2)

        double_click_frame = ctk.CTkFrame(automation_frame, fg_color="transparent")
        double_click_frame.pack(pady=5)
        ctk.CTkLabel(double_click_frame, text="Double Click", font=(self.font_type, self.font_size)).pack(side="left", padx=5)
        self.double_click_var = ctk.BooleanVar(value=self.double_click_enabled)
        self.double_click_switch = ctk.CTkSwitch(
            double_click_frame,
            text="",
            variable=self.double_click_var,
            command=self.update_double_click,
            fg_color="#ef4444",
            progress_color=self.button_color
        )
        self.double_click_switch.pack(side="left", padx=2)
        self.double_click_label = ctk.CTkLabel(double_click_frame, text="On" if self.double_click_enabled else "Off", text_color=self.button_color if self.double_click_enabled else "#ef4444")
        self.double_click_label.pack(side="left", padx=2)

        ctk.CTkLabel(automation_frame, text="Burst Count", font=(self.font_type, self.font_size)).pack(pady=5)
        self.burst_slider = ctk.CTkSlider(automation_frame, from_=1, to=10, command=self.update_burst_count, width=300, corner_radius=10)
        self.burst_slider.set(self.burst_count)
        self.burst_slider.pack(pady=5)
        self.burst_label = ctk.CTkLabel(automation_frame, text=f"{int(self.burst_count)}", font=(self.font_type, self.font_size), text_color="#e9d5ff")
        self.burst_label.pack(pady=2)

        ctk.CTkLabel(automation_frame, text="Click Limit (0 for unlimited)", font=(self.font_type, self.font_size)).pack(pady=5)
        self.click_limit_entry = ctk.CTkEntry(
            automation_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., 0"
        )
        self.click_limit_entry.insert(0, str(self.click_limit))
        self.click_limit_entry.bind("<Return>", self.update_click_limit)
        self.click_limit_entry.pack(pady=5)

        ctk.CTkLabel(automation_frame, text="Mouse Position", font=(self.font_type, self.font_size, "bold")).pack(pady=10)
        fixed_pos_frame = ctk.CTkFrame(automation_frame, fg_color="transparent")
        fixed_pos_frame.pack(pady=5)
        ctk.CTkLabel(fixed_pos_frame, text="Use Fixed Position", font=(self.font_type, self.font_size)).pack(side="left", padx=5)
        self.fixed_pos_var = ctk.BooleanVar(value=self.use_fixed_pos)
        self.fixed_pos_switch = ctk.CTkSwitch(
            fixed_pos_frame,
            text="",
            variable=self.fixed_pos_var,
            command=self.update_fixed_pos,
            fg_color="#ef4444",
            progress_color=self.button_color
        )
        self.fixed_pos_switch.pack(side="left", padx=2)
        self.fixed_pos_label = ctk.CTkLabel(fixed_pos_frame, text="On" if self.use_fixed_pos else "Off", text_color=self.button_color if self.use_fixed_pos else "#ef4444")
        self.fixed_pos_label.pack(side="left", padx=2)

        ctk.CTkButton(
            automation_frame,
            text="Capture Position",
            command=self.capture_position,
            corner_radius=15,
            fg_color="#3b82f6",
            hover_color="#60a5fa",
            font=(self.font_type, self.font_size)
        ).pack(pady=5)
        self.pos_display = ctk.CTkLabel(automation_frame, text=f"Position: {self.fixed_pos if self.fixed_pos else 'None'}", font=(self.font_type, self.font_size))
        self.pos_display.pack(pady=5)

        # Advanced Tab
        advanced_tab = tabview.add("Advanced")
        advanced_frame = ctk.CTkScrollableFrame(advanced_tab, width=390, height=450, corner_radius=15, fg_color="transparent")
        advanced_frame.pack(padx=5, pady=5, fill="both", expand=True)

        ctk.CTkLabel(advanced_frame, text="Advanced Settings", font=(self.font_type, self.font_size + 4, "bold")).pack(pady=10)
        ctk.CTkLabel(advanced_frame, text="Window and Timing", font=(self.font_type, self.font_size, "bold")).pack(pady=5)
        ctk.CTkLabel(advanced_frame, text="Window Opacity", font=(self.font_type, self.font_size)).pack(pady=5)
        self.opacity_slider = ctk.CTkSlider(advanced_frame, from_=0.4, to=1.0, command=self.update_opacity, width=300, corner_radius=10)
        self.opacity_slider.set(self.opacity)
        self.opacity_slider.pack(pady=5)
        self.opacity_label = ctk.CTkLabel(advanced_frame, text=f"{self.opacity:.2f}", font=(self.font_type, self.font_size), text_color="#e9d5ff")
        self.opacity_label.pack(pady=2)

        ctk.CTkLabel(advanced_frame, text="Auto Stop Time (seconds)", font=(self.font_type, self.font_size)).pack(pady=5)
        self.auto_stop_entry = ctk.CTkEntry(
            advanced_frame,
            width=120,
            height=35,
            corner_radius=15,
            fg_color="#2a2a3a",
            text_color="#e9d5ff",
            border_color="#8b5cf6",
            border_width=2,
            font=(self.font_type, self.font_size),
            placeholder_text="e.g., 0"
        )
        self.auto_stop_entry.insert(0, str(self.auto_stop_time))
        self.auto_stop_entry.bind("<Return>", self.update_auto_stop)
        self.auto_stop_entry.pack(pady=5)

        ctk.CTkLabel(advanced_frame, text="CPS Limit", font=(self.font_type, self.font_size)).pack(pady=5)
        self.cps_slider = ctk.CTkSlider(advanced_frame, from_=1, to=50, command=self.update_cps_limit, width=300, corner_radius=10)
        self.cps_slider.set(self.cps_limit)
        self.cps_slider.pack(pady=5)
        self.cps_label = ctk.CTkLabel(advanced_frame, text=f"{int(self.cps_limit)}", font=(self.font_type, self.font_size), text_color="#e9d5ff")
        self.cps_label.pack(pady=2)

        ctk.CTkLabel(advanced_frame, text="Mouse Jitter Amount", font=(self.font_type, self.font_size)).pack(pady=5)
        self.jitter_slider = ctk.CTkSlider(advanced_frame, from_=0, to=20, command=self.update_jitter, width=300, corner_radius=10)
        self.jitter_slider.set(self.jitter_amount)
        self.jitter_slider.pack(pady=5)
        self.jitter_label = ctk.CTkLabel(advanced_frame, text=f"{int(self.jitter_amount)}", font=(self.font_type, self.font_size), text_color="#e9d5ff")
        self.jitter_label.pack(pady=2)

        ctk.CTkLabel(advanced_frame, text="Logging", font=(self.font_type, self.font_size, "bold")).pack(pady=10)
        log_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        log_frame.pack(pady=5)
        ctk.CTkLabel(log_frame, text="Log Clicks", font=(self.font_type, self.font_size)).pack(side="left", padx=5)
        self.log_var = ctk.BooleanVar(value=self.log_enabled)
        self.log_switch = ctk.CTkSwitch(
            log_frame,
            text="",
            variable=self.log_var,
            command=self.update_log,
            fg_color="#ef4444",
            progress_color=self.button_color
        )
        self.log_switch.pack(side="left", padx=2)
        self.log_label = ctk.CTkLabel(log_frame, text="On" if self.log_enabled else "Off", text_color=self.button_color if self.log_enabled else "#ef4444")
        self.log_label.pack(side="left", padx=2)

        ctk.CTkButton(
            settings_frame,
            text="Save & Close",
            command=lambda: [self.save_settings(settings_window), settings_window.destroy()],
            corner_radius=15,
            fg_color=self.button_color,
            hover_color="#a78bfa",
            font=(self.font_type, self.font_size),
            width=300
        ).pack(pady=10)

    def update_jitter(self, value):
        self.jitter_amount = int(value)
        self.jitter_label.configure(text=f"{int(value)}")

    def update_opacity(self, value):
        self.opacity = value
        self.opacity_label.configure(text=f"{value:.2f}")
        self.root.attributes('-alpha', value)

    def update_auto_stop(self, event=None):
        try:
            time_val = int(self.auto_stop_entry.get())
            if time_val >= 0:
                self.auto_stop_time = time_val
                self.auto_stop_entry.delete(0, ctk.END)
                self.auto_stop_entry.insert(0, str(self.auto_stop_time))
            else:
                raise ValueError
        except ValueError:
            self.auto_stop_time = 0
            self.auto_stop_entry.delete(0, ctk.END)
            self.auto_stop_entry.insert(0, str(self.auto_stop_time))

    def update_cps_limit(self, value):
        self.cps_limit = int(value)
        self.cps_label.configure(text=f"{int(value)}")
        self.min_interval = 1 / self.cps_limit if self.cps_limit > 0 else 0.02

    def update_log(self):
        self.log_enabled = self.log_var.get()
        self.log_label.configure(text="On" if self.log_enabled else "Off", text_color=self.button_color if self.log_enabled else "#ef4444")

    def capture_position(self):
        msg = ctk.CTkToplevel(self.root)
        msg.title("Capture Position")
        msg.geometry("300x100")
        ctk.CTkLabel(msg, text="Move mouse to desired position and press F12 to capture").pack(pady=20)
        keyboard.on_press_key("f12", lambda e: self.set_position(msg))

    def set_position(self, msg):
        self.fixed_pos = pyautogui.position()
        self.pos_display.configure(text=f"Position: {self.fixed_pos}")
        msg.destroy()

    def update_color(self, which, value):
        if value == "Custom":
            return
        try:
            color = tuple(int(value[1:][i:i+2], 16) for i in (0, 2, 4))
            if which == "start":
                self.bg_start_color = color
                self.start_color_var.set(value)
                self.start_color_entry.delete(0, ctk.END)
                self.start_color_entry.insert(0, value)
                self.start_preview.configure(fg_color=value)
            elif which == "end":
                self.bg_end_color = color
                self.end_color_var.set(value)
                self.end_color_entry.delete(0, ctk.END)
                self.end_color_entry.insert(0, value)
                self.end_preview.configure(fg_color=value)
            self.bg_image = self.create_gradient_background()
            self.bg_label.configure(image=self.bg_image)
        except ValueError:
            pass

    def update_title_color(self, value):
        if value == "Custom":
            return
        try:
            self.title_color = value
            self.title_label.configure(text_color=value)
            self.status_label.configure(text_color=value)
            self.title_color_var.set(value)
            self.title_color_entry.delete(0, ctk.END)
            self.title_color_entry.insert(0, value)
            self.title_preview.configure(fg_color=value)
        except ValueError:
            pass

    def update_button_color(self, value):
        if value == "Custom":
            return
        try:
            self.button_color = value
            self.start_stop_btn.configure(fg_color=value, border_color=value)
            self.mouse_move_switch.configure(progress_color=value)
            self.double_click_switch.configure(progress_color=value)
            self.fixed_pos_switch.configure(progress_color=value)
            self.log_switch.configure(progress_color=value)
            self.button_color_var.set(value)
            self.button_color_entry.delete(0, ctk.END)
            self.button_color_entry.insert(0, value)
            self.button_preview.configure(fg_color=value)
        except ValueError:
            pass

    def update_font_size(self, value):
        self.font_size = int(value)
        self.font_size_label.configure(text=f"{int(value)}")
        self.update_ui_fonts()

    def update_font_type(self, value):
        self.font_type = value
        self.update_ui_fonts()

    def update_ui_fonts(self):
        self.title_label.configure(font=(self.font_type, self.font_size + 16, "bold"))
        self.status_label.configure(font=(self.font_type, self.font_size))
        self.click_type.configure(font=(self.font_type, self.font_size))
        self.key_entry.configure(font=(self.font_type, self.font_size))
        self.hotkey_entry.configure(font=(self.font_type, self.font_size))
        self.start_stop_btn.configure(font=(self.font_type, self.font_size + 4, "bold"))
        self.settings_btn.configure(font=(self.font_type, self.font_size))
        self.reset_button.configure(font=(self.font_type, self.font_size))

    def update_click_duration(self, event=None):
        try:
            duration = int(self.click_duration_entry.get())
            if duration >= 0:
                self.click_duration = duration
                self.click_duration_entry.delete(0, ctk.END)
                self.click_duration_entry.insert(0, str(self.click_duration))
            else:
                raise ValueError
        except ValueError:
            self.click_duration = 0
            self.click_duration_entry.delete(0, ctk.END)
            self.click_duration_entry.insert(0, str(self.click_duration))

    def update_random_delay(self, value):
        self.random_delay = int(value)
        self.random_delay_label.configure(text=f"{int(value)} ms")

    def update_mouse_move(self):
        self.mouse_move_enabled = self.mouse_move_var.get()
        self.mouse_move_label.configure(text="On" if self.mouse_move_enabled else "Off", text_color=self.button_color if self.mouse_move_enabled else "#ef4444")

    def update_double_click(self):
        self.double_click_enabled = self.double_click_var.get()
        self.double_click_label.configure(text="On" if self.double_click_enabled else "Off", text_color=self.button_color if self.double_click_enabled else "#ef4444")

    def update_burst_count(self, value):
        self.burst_count = int(value)
        self.burst_label.configure(text=f"{int(value)}")

    def update_click_limit(self, event=None):
        try:
            limit = int(self.click_limit_entry.get())
            if limit >= 0:
                self.click_limit = limit
                self.click_limit_entry.delete(0, ctk.END)
                self.click_limit_entry.insert(0, str(self.click_limit))
            else:
                raise ValueError
        except ValueError:
            self.click_limit = 0
            self.click_limit_entry.delete(0, ctk.END)
            self.click_limit_entry.insert(0, str(self.click_limit))

    def update_fixed_pos(self):
        self.use_fixed_pos = self.fixed_pos_var.get()
        self.fixed_pos_label.configure(text="On" if self.use_fixed_pos else "Off", text_color=self.button_color if self.use_fixed_pos else "#ef4444")

    def save_settings(self, window):
        try:
            start_color = self.start_color_entry.get()
            end_color = self.end_color_entry.get()
            title_color = self.title_color_entry.get()
            button_color = self.button_color_entry.get()
            self.bg_start_color = tuple(int(start_color[1:][i:i+2], 16) for i in (0, 2, 4))
            self.bg_end_color = tuple(int(end_color[1:][i:i+2], 16) for i in (0, 2, 4))
            self.title_color = title_color
            self.button_color = button_color
            self.bg_image = self.create_gradient_background()
            self.bg_label.configure(image=self.bg_image)
            self.title_label.configure(text_color=self.title_color)
            self.status_label.configure(text_color=self.title_color)
            self.start_stop_btn.configure(fg_color=self.button_color, border_color=self.button_color)
            self.reset_button.configure(fg_color="#ef4444")
            self.settings_btn.configure(fg_color="#3b82f6")
            self.mouse_move_switch.configure(progress_color=self.button_color)
            self.double_click_switch.configure(progress_color=self.button_color)
            self.fixed_pos_switch.configure(progress_color=self.button_color)
            self.log_switch.configure(progress_color=self.button_color)
            self.update_click_duration()
            self.update_click_limit()
        except ValueError:
            pass

    def load_state(self):
        # Load settings from config file
        config_path = "config.txt"
        if os.path.exists(config_path):
            with open(config_path, "r") as f:
                state = json.load(f)
                self.current_key = state.get("current_key", "None")
                self.hotkey = state.get("hotkey", "f6")
                self.bg_start_color = tuple(state.get("bg_start_color", (25, 15, 60)))
                self.bg_end_color = tuple(state.get("bg_end_color", (70, 50, 180)))
                self.button_color = state.get("button_color", "#8b5cf6")
                self.title_color = state.get("title_color", "#e9d5ff")
                self.font_size = state.get("font_size", 16)
                self.font_type = state.get("font_type", "Inter")
                self.click_type_value = state.get("click_type", "None")
                self.click_duration = state.get("click_duration", 0)
                self.random_delay = state.get("random_delay", 0)
                self.mouse_move_enabled = state.get("mouse_move_enabled", False)
                self.double_click_enabled = state.get("double_click_enabled", False)
                self.burst_count = state.get("burst_count", 1)
                self.click_limit = state.get("click_limit", 0)
                self.use_fixed_pos = state.get("use_fixed_pos", False)
                self.fixed_pos = tuple(state.get("fixed_pos", None)) if state.get("fixed_pos") else None
                self.opacity = state.get("opacity", 0.95)
                self.auto_stop_time = state.get("auto_stop_time", 0)
                self.cps_limit = state.get("cps_limit", 50)
                self.log_enabled = state.get("log_enabled", False)
                self.jitter_amount = state.get("jitter_amount", 0)
                self.min_interval = state.get("min_interval", 0.02)

    def save_state(self):
        # Save settings to config file
        config_path = "config.txt"
        state = {
            "current_key": self.current_key,
            "hotkey": self.hotkey,
            "bg_start_color": list(self.bg_start_color),
            "bg_end_color": list(self.bg_end_color),
            "button_color": self.button_color,
            "title_color": self.title_color,
            "font_size": self.font_size,
            "font_type": self.font_type,
            "click_type": self.click_type.get(),
            "click_duration": self.click_duration,
            "random_delay": self.random_delay,
            "mouse_move_enabled": self.mouse_move_enabled,
            "double_click_enabled": self.double_click_enabled,
            "burst_count": self.burst_count,
            "click_limit": self.click_limit,
            "use_fixed_pos": self.use_fixed_pos,
            "fixed_pos": list(self.fixed_pos) if self.fixed_pos else None,
            "opacity": self.opacity,
            "auto_stop_time": self.auto_stop_time,
            "cps_limit": self.cps_limit,
            "log_enabled": self.log_enabled,
            "jitter_amount": self.jitter_amount,
            "min_interval": self.min_interval
        }
        with open(config_path, "w") as f:
            json.dump(state, f)

    def on_closing(self):
        # Clean up on window close
        self.is_running = False
        self.save_state()
        keyboard.unhook_all()
        self.root.destroy()

if __name__ == "__main__":
    root = ctk.CTk()
    app = AutoClickerApp(root)
    root.mainloop()
