import os
import json
import threading
import queue as pyqueue
import subprocess
import traceback
import tkinter as tk
from tkinter import filedialog, messagebox
import customtkinter as ctk
from yt_dlp import YoutubeDL

SETTINGS_FILE = "settings.json"

# ---------------- Settings ----------------
class SettingsManager:
    def __init__(self, path=SETTINGS_FILE):
        self.path = path
        self.data = {
            "download_dir": "",
            "ask_folder": True,
            "cookies": "",
            "audio_format": "mp3",
            "audio_bitrate": "192",
            "video_format": "mp4",
            "video_quality": "best",
            "simultaneous_downloads": 1
        }
        self.load()
    def load(self):
        if os.path.exists(self.path):
            try:
                with open(self.path, "r", encoding="utf-8") as f:
                    self.data.update(json.load(f))
            except Exception:
                print("Failed to load settings. Using defaults.")
    def save(self):
        try:
            with open(self.path, "w", encoding="utf-8") as f:
                json.dump(self.data, f, indent=4)
        except Exception as e:
            print("Failed to save settings:", e)

# ---------------- Queue ----------------
class QueueManager:
    def __init__(self):
        self.items = []
    def add(self, url, title, type_):
        item = {'url': url, 'title': title or url, 'type': type_, 'progress': 0.0, 'status': 'queued'}
        self.items.append(item)
        return item
    def remove(self, index):
        if 0 <= index < len(self.items):
            del self.items[index]
    def clear(self):
        self.items.clear()

# ---------------- Downloader ----------------
class Downloader:
    def __init__(self, settings: SettingsManager, gui_queue: pyqueue.Queue, queue_mgr: QueueManager):
        self.settings = settings
        self.gui_q = gui_queue
        self.queue_mgr = queue_mgr
        self.running = False
    def start_downloads(self):
        if self.running:
            return
        self.running = True
        threading.Thread(target=self._download_thread, daemon=True).start()
    def stop(self):
        self.running = False
    def _download_thread(self):
        if not self.queue_mgr.items:
            self.running = False
            return
        while self.queue_mgr.items and self.running:
            item = self.queue_mgr.items[0]
            idx = 0
            self.gui_q.put(('status', idx, 'downloading'))

            save_path = self.settings.data.get('download_dir') or filedialog.askdirectory(title="Select download directory")
            if not save_path:
                self.running = False
                return
            self.settings.data['download_dir'] = save_path

            cookies_file = self.settings.data.get('cookies') or None

            # Download options
            if item['type'] == 'audio':
                file_type = self.settings.data.get('audio_format','mp3')
                bitrate = self.settings.data.get('audio_bitrate','192')
                ydl_opts = {
                    'outtmpl': os.path.join(save_path, '%(title)s.%(ext)s'),
                    'format':'bestaudio/best',
                    'noplaylist': True,
                    'quiet': True,
                    'progress_hooks':[lambda d:self._progress_hook(d, idx)]
                }
                if cookies_file: ydl_opts['cookiefile'] = cookies_file
                ydl_opts['postprocessors']=[{'key':'FFmpegExtractAudio',
                                             'preferredcodec':file_type,
                                             'preferredquality':str(bitrate)}]
            else:  # video
                file_type = self.settings.data.get('video_format','mp4')
                quality = self.settings.data.get('video_quality','best')
                ydl_opts = {
                    'outtmpl': os.path.join(save_path, '%(title)s.%(ext)s'),
                    'format': quality,
                    'noplaylist': True,
                    'quiet': True,
                    'progress_hooks':[lambda d:self._progress_hook(d, idx)]
                }
                if cookies_file: ydl_opts['cookiefile'] = cookies_file

            try:
                with YoutubeDL(ydl_opts) as ydl:
                    ydl.download([item['url']])
                self.gui_q.put(('progress', idx,1.0))
                self.gui_q.put(('status', idx,'done'))
            except Exception as e:
                tb = traceback.format_exc()
                print("Download error:",e,tb)
                self.gui_q.put(('status', idx,'error'))
                self.gui_q.put(('error', idx,str(e)))
            self.queue_mgr.remove(0)
        self.running = False

    def _progress_hook(self, d, idx):
        if d.get('status')=='downloading':
            downloaded = d.get('downloaded_bytes',0)
            total = d.get('total_bytes') or d.get('total_bytes_estimate',1)
            frac = float(downloaded)/max(int(total),1)
            self.gui_q.put(('progress', idx, min(max(frac,0.0),1.0)))

# ---------------- UI ----------------
class UIManager:
    def __init__(self, root, settings, queue_mgr):
        self.root = root
        self.settings = settings
        self.queue_mgr = queue_mgr
        self.gui_q = pyqueue.Queue()
        self.downloader = Downloader(settings,self.gui_q,queue_mgr)
        self.pages = {}
        self._build_ui()
        self.root.after(100,self._process_gui_updates)

    def _build_ui(self):
        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("green")
        self.root.title("YouTube Downloader Pro")
        self.root.geometry("1100x800")
        self.root.minsize(1000,720)

        # Sidebar
        self.sidebar = ctk.CTkFrame(self.root,width=220)
        self.sidebar.pack(side="left",fill="y")
        ctk.CTkLabel(self.sidebar,text="Downloader Pro",font=("Helvetica",18,"bold")).pack(pady=12)
        for name,cmd in [("Single Video",self.show_single_video),
                         ("Single Music",self.show_single_music),
                         ("Queue",self.show_queue),
                         ("Settings",self.show_settings)]:
            ctk.CTkButton(self.sidebar,text=name,command=cmd,width=200,height=40).pack(pady=6)

        # Content frame
        self.content_frame = ctk.CTkFrame(self.root)
        self.content_frame.pack(side="right",expand=True,fill="both")
        self.show_single_video()

    def _clear_content(self):
        for c in self.content_frame.winfo_children():
            c.destroy()

    # ---------------- Single Video ----------------
    def show_single_video(self):
        self._clear_content()
        page = self.content_frame
        url_entry=ctk.CTkEntry(page,width=780,placeholder_text="Enter YouTube Video URL")
        url_entry.pack(pady=6)
        fmt_var = tk.StringVar(value=self.settings.data.get('video_format','mp4'))
        quality_var = tk.StringVar(value=self.settings.data.get('video_quality','best'))
        ctk.CTkOptionMenu(page, values=["mp4","mkv","webm"], variable=fmt_var,
                           command=lambda v:self._update_setting('video_format',v)).pack(pady=4)
        ctk.CTkOptionMenu(page, values=["best","360","720","1080"], variable=quality_var,
                           command=lambda v:self._update_setting('video_quality',v)).pack(pady=4)
        def add_video_queue():
            url=url_entry.get().strip()
            if url:
                self.queue_mgr.add(url,url,'video')
                self.show_queue()
        ctk.CTkButton(page,text="Add to Queue",command=add_video_queue,width=200).pack(pady=10)

    # ---------------- Single Music ----------------
    def show_single_music(self):
        self._clear_content()
        page = self.content_frame
        url_entry=ctk.CTkEntry(page,width=780,placeholder_text="Enter YouTube Audio URL")
        url_entry.pack(pady=6)
        fmt_var = tk.StringVar(value=self.settings.data.get('audio_format','mp3'))
        br_var = tk.StringVar(value=self.settings.data.get('audio_bitrate','192'))
        ctk.CTkOptionMenu(page, values=["mp3","aac","wav"], variable=fmt_var,
                           command=lambda v:self._update_setting('audio_format',v)).pack(pady=4)
        ctk.CTkOptionMenu(page, values=["128","192","320"], variable=br_var,
                           command=lambda v:self._update_setting('audio_bitrate',v)).pack(pady=4)
        def add_audio_queue():
            url=url_entry.get().strip()
            if url:
                self.queue_mgr.add(url,url,'audio')
                self.show_queue()
        ctk.CTkButton(page,text="Add to Queue",command=add_audio_queue,width=200).pack(pady=10)

    # ---------------- Queue ----------------
    def show_queue(self):
        self._clear_content()
        page = self.content_frame
        ctrls=ctk.CTkFrame(page)
        ctrls.pack(fill="x",pady=6)
        ctk.CTkButton(ctrls,text="Start Queue",command=self.downloader.start_downloads,width=160).pack(side="left",padx=6)
        ctk.CTkButton(ctrls,text="Stop Downloads",command=self.downloader.stop,width=160).pack(side="left",padx=6)
        ctk.CTkButton(ctrls,text="Clear Queue",command=lambda:[self.queue_mgr.clear(),self.refresh_queue_list()],width=160).pack(side="left",padx=6)
        self.queue_scroll=ctk.CTkScrollableFrame(page,width=900,height=480,fg_color="#121212")
        self.queue_scroll.pack(pady=10)
        self.refresh_queue_list()

    def refresh_queue_list(self):
        for c in self.queue_scroll.winfo_children():
            c.destroy()
        for idx,item in enumerate(self.queue_mgr.items):
            frame=ctk.CTkFrame(self.queue_scroll,height=50)
            frame.pack(fill="x",pady=4,padx=6)
            title_lbl=ctk.CTkLabel(frame,text=f"[{item['type']}] {item['title']}",anchor="w")
            title_lbl.pack(side="left",padx=8,fill="x",expand=True)
            pb=ctk.CTkProgressBar(frame,width=200)
            pb.pack(side="right",padx=6)
            pb.set(item.get('progress',0.0))
            item['pb']=pb

    def _process_gui_updates(self):
        while not self.gui_q.empty():
            try:
                msg = self.gui_q.get_nowait()
                if msg[0]=='progress':
                    idx,val = msg[1],msg[2]
                    if self.queue_mgr.items:
                        item = self.queue_mgr.items[0]
                        item['progress']=val
                        if 'pb' in item:
                            item['pb'].set(val)
                elif msg[0]=='status':
                    idx,status = msg[1],msg[2]
                    if self.queue_mgr.items:
                        item = self.queue_mgr.items[0]
                        item['status']=status
                elif msg[0]=='error':
                    idx,err = msg[1],msg[2]
                    if self.queue_mgr.items:
                        item=self.queue_mgr.items[0]
                        item['status']='error'
                        messagebox.showerror("Download Error",f"{item['title']}\n{err}")
                self.refresh_queue_list()
            except Exception as e:
                print("GUI update error:",e)
        self.root.after(100,self._process_gui_updates)

    # ---------------- Settings ----------------
    def show_settings(self):
        self._clear_content()
        page = self.content_frame
        # Download directory
        dir_frame=ctk.CTkFrame(page)
        dir_frame.pack(fill="x",pady=6)
        dir_var=tk.StringVar(value=self.settings.data.get('download_dir',''))
        ctk.CTkLabel(dir_frame,text="Download Directory:").pack(side="left",padx=6)
        ctk.CTkEntry(dir_frame,textvariable=dir_var).pack(side="left",fill="x",expand=True,padx=6)
        def browse_dir():
            p=filedialog.askdirectory()
            if p:
                dir_var.set(p)
                self._update_setting('download_dir',p)
        ctk.CTkButton(dir_frame,text="Browse",command=browse_dir,width=120).pack(side="left",padx=6)
        # Cookies file
        cookie_frame=ctk.CTkFrame(page)
        cookie_frame.pack(fill="x",pady=6)
        cookie_var=tk.StringVar(value=self.settings.data.get('cookies',''))
        ctk.CTkLabel(cookie_frame,text="Cookies File:").pack(side="left",padx=6)
        ctk.CTkEntry(cookie_frame,textvariable=cookie_var).pack(side="left",fill="x",expand=True,padx=6)
        def browse_cookie():
            f=filedialog.askopenfilename(filetypes=[("Cookies files","*.txt")])
            if f:
                cookie_var.set(f)
                self._update_setting('cookies',f)
        ctk.CTkButton(cookie_frame,text="Browse",command=browse_cookie,width=120).pack(side="left",padx=6)
        # Ask folder each time
        ask_var = tk.BooleanVar(value=self.settings.data.get('ask_folder',True))
        ctk.CTkCheckBox(page,text="Ask download folder each time",variable=ask_var,
                         command=lambda:self._update_setting('ask_folder',ask_var.get())).pack(pady=6)
        # Simultaneous downloads
        sim_frame=ctk.CTkFrame(page)
        sim_frame.pack(fill="x",pady=6)
        sim_var=tk.IntVar(value=self.settings.data.get('simultaneous_downloads',1))
        ctk.CTkLabel(sim_frame,text="Simultaneous Downloads:").pack(side="left",padx=6)
        ctk.CTkEntry(sim_frame,textvariable=sim_var,width=60).pack(side="left",padx=6)
        def update_sim(e=None):
            self._update_setting('simultaneous_downloads',sim_var.get())
        sim_var.trace_add("write", lambda *args: update_sim())

    def _update_setting(self,key,value):
        self.settings.data[key]=value
        self.settings.save()

# ---------------- Main ----------------
if __name__=="__main__":
    settings=SettingsManager()
    queue_mgr=QueueManager()
    root=ctk.CTk()
    ui=UIManager(root,settings,queue_mgr)
    def on_close():
        settings.save()
        root.destroy()
    root.protocol("WM_DELETE_WINDOW",on_close)
    root.mainloop()
